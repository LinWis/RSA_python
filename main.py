import random
from pprint import pprint
from typing import Tuple


# В каждой функции реализована аннотация типов
# и по возможно было проведено соблюдение правил написания кода(отступы и пр.)

# Алгоритм быстрого возведения в степень по модулю
def fast_exp(b: int, e: int, m: int) -> int:
    r = 1
    if 1 & e:
        r = b
    while e:
        e >>= 1
        b = (b * b) % m
        if e & 1:
            r = (r * b) % m
    return r


# Тест Миллера-Рабина
def miller_rabin(n: int, k=40) -> bool:
    # k - кол-во тестов, оптимальный минимум - 40
    # Возращает True, если число простое

    if n == 2:
        return True

    if n % 2 == 0:
        return False

    r, s = 0, n - 1
    while s % 2 == 0:
        r += 1
        s //= 2
    for _ in range(k):
        a = random.randrange(2, n - 1)
        x = fast_exp(a, s, n)
        if x == 1 or x == n - 1:
            continue
        for _ in range(r - 1):
            x = fast_exp(x, 2, n)
            if x == n - 1:
                break
        else:
            return False
    return True


# Расширенный алгоритм Евклида
def extend_gcd(a: int, b: int) -> Tuple[int, int, int]:
    # Возрашает (g, x, y) где, a*x + b*y = g = gcd(a, b)
    x0, x1, y0, y1 = 0, 1, 1, 0
    while a != 0:
        (q, a), b = divmod(b, a), a
        y0, y1 = y1, y0 - q * y1
        x0, x1 = x1, x0 - q * x1
    return b, x0, y0


# Функция для генерации двух простых чисел
def gen_simple() -> Tuple[int, int]:
    a = -1
    b = -1
    while a == -1 or b == -1:
        x = random.randint(2**10, 2**1024)  # Здесь диапозон значений для p и q
        if miller_rabin(x):
            if a != -1:
                return a, x
            else:
                a = x

# -------------------------------------------- Считаем ключи --------------------------------------------
# Рандомно берем числа p и q, и проверяем с помощью теста Миллера-Рабинна
p, q = gen_simple()

n = p * q  # Первый открытый ключ
print(f"{n} - первый открытый ключ")

# Функция Эйлера
fn = (p - 1) * (q - 1)

# Выбираем рандомно второй открытый ключ e, и проверяем его на взаимною простоту с числом Эйлера,
# использую для этого расширенный алгоритм евклида, а так же запоминнаю первый коэфициент Безу
# который так же является нашим обратным вычетом

e = random.randint(3, fn - 1)
nod, obr_vich, _ = extend_gcd(e, fn)
while nod != 1:
    e = random.randint(3, fn - 1)
    nod, obr_vich, _ = extend_gcd(e, fn)

print(f"{e} - второй открытый ключ")

#Считаем закрытый ключ
d = obr_vich % fn

if (d * e) % fn == 1:
    print(f"{d} - закрытый ключ")
else:
    print("Произошла ошибка вычеслений, попробуйте заново(Проблема может быть связана с тестом Миллера-Рабина)")
    exit()

# -------------------------------------------- Основная часть программы --------------------------------------------

M = [] # Список для зашифрованного сообщения
M_de = "" # Расшифрованное сообщение
while True:
    x = int(input("Введите номер действия:\n\t1 - Зашифровать сообщение\n\t2 - Расшифровать сообщение\n\t3 - выход\n"))
    if x == 1:
        m = input("Введите сообщение, которое хотите зашифровать: ")
        mr = []
        for i in m:
            mr.append(fast_exp(ord(i), e, n)) # Кодируем сообщение по символам,
            # использую кодировку каждой буквы(функция ord())
        M = mr.copy()
        print("Полученное зашифрованное сообщение: ")
        pprint(M)

    elif x == 2:
        mr = ""
        for i in M:
            mr += chr(fast_exp(i, d, n)) # Получаем символ по его коду
        M_de = mr
        print(f"Полученное зашифрованное сообщение: {M_de}")

    elif x == 3:
        break
    else:
        print("Неправильный формат ввода! Попробуйте ещё раз!\n")
